\chapter{Аналитическая часть}

В данном разделе рассматриваются ключевые понятия, протоколы и механизмы операционной системы,
лежащие в основе разработанного HTTP-сервера.

\section{Протокол HTTP}

\textit{HyperText Transfer Protocol} (HTTP) -- это прикладной протокол передачи данных,
лежащий в основе обмена информацией в сети. Он использует модель <<клиент-сервер>>,
где клиент отправляет запрос, а сервер возвращает ответ~\cite{net}.

HTTP версий 1.0 и 1.1, поддерживаемые в данной работе, работают поверх транспортного протокола TCP.
Каждое соединение устанавливается отдельно (в HTTP/1.0) или может переиспользоваться (в HTTP/1.1).
Запрос состоит из:
\begin{enumerate}[label=\arabic*), labelsep=0.5em]
    \item Стартовой строки (например, \texttt{GET /index.html HTTP/1.1});
    \item Заголовков (headers) в формате <<ключ: значение>>;
    \item Пустой строки \texttt{\textbackslash r\textbackslash n\textbackslash r\textbackslash n};
    \item Необязательного тела (body).
\end{enumerate}

Методы \texttt{GET} и \texttt{HEAD} используются для получения ресурса.
Отличие заключается в том, что при \texttt{HEAD} сервер возвращает только заголовки ответа без тела.
Это позволяет клиенту проверить метаданные, например, размер или дату изменения без передачи всего содержимого.

Сервер должен формировать HTTP-ответы с кодами состояния:
\begin{itemize}
    \item[---] 200 (\textit{OK}) -- успешная обработка запроса;
    \item[---] 403 (\textit{Forbidden}) -- доступ к ресурсу запрещён;
    \item[---] 404 (\textit{Not Found}) -- запрашиваемый ресурс не найден;
    \item[---] 405 (\textit{Method Not Allowed}) -- использован неподдерживаемый HTTP-метод.
\end{itemize}

\section{Мультиплексирование}

Мультиплексирование -- это способность одного потока или процесса одновременно управлять множеством сетевых соединений.
Для реализации мультиплексирования в Unix-подобных системах используются системные вызовы:
\begin{itemize}
    \item[---] \textit{select()}, \textit{poll()} -- классические механизмы опроса множества файловых дескрипторов;
    \item[---] \textit{epoll()} (Linux) или \textit{kqueue()} (BSD, macOS) -- масштабируемые альтернативы.
\end{itemize}

В данной работе выбран вызов \texttt{poll()}. Он позволяет потоку ожидать готовности любого из набора сокетов
к чтению или записи, не блокируя выполнение программы и не требуя отдельного потока на каждое соединение~\cite{server}.

\section{Архитектура <<пул потоков>>}

Пул потоков (thread pool) -- это шаблон проектирования, при котором создаётся фиксированное количество рабочих потоков
при старте программы. Входящие задачи (сетевые соединения) помещаются в очередь и распределяются между свободными потоками.

Преимущества:
\begin{itemize}
    \item[---] Снижение накладных расходов на создание/уничтожение потоков;
    \item[---] Контролируемое потребление памяти и CPU;
    \item[---] Возможность балансировки нагрузки.
\end{itemize}

В разработанном сервере пул потоков комбинируется с мультиплексированием:
каждый рабочий поток сам управляет множеством сокетов через \textit{poll()}.

\section{Механизмы межпоточного взаимодействия}

Для передачи новых соединений от главного потока (слушающего \textit{accept()}) к рабочим потокам используется
механизм \textit{анонимных каналов} (anonymous pipes).

Pipe -- это односторонний канал связи между процессами или потоками, реализованный через два файловых дескриптора~\cite{pipe}:
\begin{itemize}
    \item[---] \textit{fd[1]} -- дескриптор для записи;
    \item[---] \textit{fd[0]} -- дескриптор для чтения.
\end{itemize}

В данной реализации каждый рабочий поток имеет свой pipe.
Главный поток записывает в него структуру с новым сокетом, IP и портом клиента.
Рабочий поток добавляет этот сокет в свой набор для \textit{poll()}, тем самым принимая соединение на обслуживание.
Каналы также используются для сигнализации о завершении работы.

\section{Обеспечение безопасности}

При разработке сервера статического содержимого критически важна защита от атак типа \textit{Path Traversal} (обход каталогов),
при которых злоумышленник пытается получить доступ к файлам вне корневой директории (например, \textit{GET /../../../../etc/passwd}).

Для предотвращения таких атак реализована функция \textit{is\_path\_safe()}, которая:
\begin{itemize}
    \item[---] Нормализует путь с помощью \textit{realpath()}, разрешая символические ссылки и удаляя \textit{..} и \textit{.};
    \item[---] Сравнивает полученный абсолютный путь с каноническим путём корневой директории;
    \item[---] Разрешает доступ только если результирующий путь находится внутри корневой директории.
\end{itemize}

Также сервер ограничивает максимальный размер отдаваемого файла (128 МБ) и
не позволяет отдавать содержимое каталогов (возвращается 403).

\section{Логирование}

Ведение журнала событий (логирование) необходимо для мониторинга, отладки и аудита.
Сервер реализует запись в лог-файл в формате, близком к Common Log Format (CLF):
\begin{center}
    \begin{verbatim}
        [время_в_UTC] [IP:порт] "МЕТОД ПУТЬ" КОД_СТАТУСА ОБЪЁМ.
    \end{verbatim}
\end{center}

Для обеспечения потокобезопасности при записи из нескольких рабочих потоков используется мьютекс
(\textit{pthread\_mutex\_t}), защищающий критическую секцию \textit{fprintf()}.
